//TODO: CHANGE TO SPRINT 2 
spec BusBoss_sprint01

define NUM_BUSSES := 6;
define MAX_STATIONS_TO_GAS_STATION := 10;
define MAX_UNSTOPPED_STATIONS := 4;
define NUM_STATIONS := 10;
define NUM_LINES := 4;

// ____scenarios_____
//TODO: If it is raining, than the bus should wait 2 steps in each station it stops at in order to help passengers get settled
env boolean isRaining;


//Lines
define A := 0;
define B := 1;
define G_W := 2;
define G_E := 3;

sys boolean[NUM_LINES] extraBusSentLine;
sys boolean[NUM_LINES] needExtraBusForLine;

//_______Stations________

env boolean [NUM_STATIONS] arePassengersWaiting;

//Local Stations
define a1 := 0;
define a2 := 1;

define b1 := 2;
define b2 := 3;

// General Line Stations
define g1_w := 4;
define g2_w := 5;

define g1_e := 6;
define g2_e := 7;

//Other Stations
define main_station := 8;
define gas_station := 9;

// TODO: Add guarantee - if 2 busses are in the same station, only one of them can continue to destination station.
// TODO: Add guarantee - if some bus is in x station, then it's next station can be: next_station_of_bus_path OR wait (which means nextStation = currStation)
// TODO: Add guarantee - if some bus need to wait in the station, origin and destination should remain the same - think about it, maybe should be implemented in GUI
// TODO: Add asm - if some bus need to wait in the station and not at destination station yet, next(atDestinationStation) = atDestinationStation
// wait == stop ?

// ______Routes________

//TODO: set real stations
// Routes lengths
define line_A_length := 3;
define line_B_length := 3;
define line_G_W_length := 3;
define line_G_E_length := 3;
define a1_to_gas_station_length := 4;
define a2_to_gas_station_length := 2;
define b1_to_gas_station_length := 3;
define b2_to_gas_station_length := 3;
define g1_w_to_gas_station_length := 3;
define g2_w_to_gas_station_length := 3;
define g1_e_to_gas_station_length := 3;
define g2_e_to_gas_station_length := 3;
define main_station_to_gas_station_length := 3;

// TODO: Stopped here!!!
//define a1 := 0;
//define a2 := 1;
//define b1 := 2;
//define b2 := 3;
//define g1_w := 4;
//define g2_w := 5;
//define g1_e := 6;
//define g2_e := 7;
//define main_station := 8;
//define gas_station := 9;
// Routes of lines
define line_A_route[line_A_length] := {8, 0, 1};
define line_B_route[line_B_length] := {8, 2, 3};
define line_G_W_route[line_G_W_length] := {8, 4, 5};
define line_G_E_route[line_G_E_length] := {8, 7, 6};

// Routes from every station to gas_station
define a1_to_gas_station_route[a1_to_gas_station_length] := {0, 4, 1, 9};
define a2_to_gas_station_route[a2_to_gas_station_length] := {1, 9};
define b1_to_gas_station_route[b1_to_gas_station_length] := {2, 0, 0};
define b2_to_gas_station_route[b2_to_gas_station_length] := {0, 0, 0};
define g1_w_to_gas_station_route[g1_w_to_gas_station_length] := {0, 0, 0};
define g2_w_to_gas_station_route[g2_w_to_gas_station_length] := {0, 0, 0};
define g1_e_to_gas_station_route[g1_e_to_gas_station_length] := {0, 0, 0};
define g2_e_to_gas_station_route[g2_e_to_gas_station_length] := {0, 0, 0};
define main_station_to_gas_station_route[main_station_to_gas_station_length] := {0, 0, 0};

//_______Busses________

type Bus = Int(0..(NUM_BUSSES - 1));

env boolean [NUM_BUSSES] isBusFull;
env boolean[NUM_BUSSES] isStopPressed;
env boolean[NUM_BUSSES] atDestinationStation;

sys Int(0..3)[NUM_BUSSES] lineOfBus;
sys boolean[NUM_BUSSES] inUse;
sys Int(0..(NUM_STATIONS - 1))[NUM_BUSSES] originStation;
sys Int(0..(NUM_STATIONS - 1))[NUM_BUSSES] destinationStation;
sys boolean[NUM_BUSSES] stopAtNextStation;
sys boolean[NUM_BUSSES] shouldGoToGasStation;


predicate atSpecificDestinationStation(Bus bus, Int(0..(NUM_STATIONS - 1)) station):
	atDestinationStation[bus] & (destinationStation[bus] = station);

// Guarantee for each line: if at destinantionStation and shouldn't go to gas station(!), set new destination to be next station of line route and origin to be old destination. 
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(line_A_length-1)). 
	( (lineOfBus[bus] = 0) & (!shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = line_A_route[i]) ) ->  
	( next(destinationStation[bus]) = line_A_route[(i+1)%line_A_length] & next(originStation[bus]) = line_A_route[(i)%line_A_length] );
	
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(line_B_length-1)). 
	( (lineOfBus[bus] = 0) & (!shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = line_B_route[i]) ) ->  
	( next(destinationStation[bus]) = line_B_route[(i+1)%line_B_length] & next(originStation[bus]) = line_B_route[(i)%line_B_length] );

gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(line_G_W_length-1)). 
	( (lineOfBus[bus] = 0) & (!shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = line_G_W_route[i]) ) ->  
	( next(destinationStation[bus]) = line_G_W_route[(i+1)%line_G_W_length] & next(originStation[bus]) = line_G_W_route[(i)%line_G_W_length] );

gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(line_G_E_length-1)). 
	( (lineOfBus[bus] = 0) & (!shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = line_G_E_route[i]) ) ->  
	( next(destinationStation[bus]) = line_G_E_route[(i+1)%line_G_E_length] & next(originStation[bus]) = line_G_E_route[(i)%line_G_E_length] );

// Guarantee for each line: if at destinationStation and should go to gas station, set new destination to be next station of from_destination_Station_to_gas_station route and origin to be old destination.
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(a1_to_gas_station_length-2)). 
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = a1_to_gas_station_route[i]) ) ->  
	( next(destinationStation[bus]) = a1_to_gas_station_route[(i+1)] & next(originStation[bus]) = a1_to_gas_station_route[(i)] );
	
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(a2_to_gas_station_length-2)). 
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = a2_to_gas_station_route[i]) ) ->  
	( next(destinationStation[bus]) = a2_to_gas_station_route[(i+1)] & next(originStation[bus]) = a2_to_gas_station_route[(i)] );
	
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(b1_to_gas_station_length-2)). 
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = b1_to_gas_station_route[i]) ) ->  
	( next(destinationStation[bus]) = b1_to_gas_station_route[(i+1)] & next(originStation[bus]) = b1_to_gas_station_route[(i)] );

gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(b2_to_gas_station_length-2)). 
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = b2_to_gas_station_route[i]) ) ->  
	( next(destinationStation[bus]) = b2_to_gas_station_route[(i+1)] & next(originStation[bus]) = b2_to_gas_station_route[(i)] );
	
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(g1_w_to_gas_station_length-2)). 
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = g1_w_to_gas_station_route[i]) ) ->  
	( next(destinationStation[bus]) = g1_w_to_gas_station_route[(i+1)] & next(originStation[bus]) = g1_w_to_gas_station_route[(i)] );
	
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(g2_w_to_gas_station_length-2)). 
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = g2_w_to_gas_station_route[i]) ) ->  
	( next(destinationStation[bus]) = g2_w_to_gas_station_route[(i+1)] & next(originStation[bus]) = g2_w_to_gas_station_route[(i)] );
	
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(g1_e_to_gas_station_length-2)). 
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = g1_e_to_gas_station_route[i]) ) ->  
	( next(destinationStation[bus]) = g1_e_to_gas_station_route[(i+1)] & next(originStation[bus]) = g1_e_to_gas_station_route[(i)] );
	
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(g2_e_to_gas_station_length-2)). 
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = g2_e_to_gas_station_route[i]) ) ->  
	( next(destinationStation[bus]) = g2_e_to_gas_station_route[(i+1)] & next(originStation[bus]) = g2_e_to_gas_station_route[(i)] );
	
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(main_station_to_gas_station_length-2)). 
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = main_station_to_gas_station_route[i]) ) ->  
	( next(destinationStation[bus]) = main_station_to_gas_station_route[(i+1)] & next(originStation[bus]) = main_station_to_gas_station_route[(i)] );

// Guarantee for each bus: if should go to gas station and bus is at gas station, set shouldGoToGasStation to false and go back to main station.
// TODO: GUI will know how to move a bus from gas station to main station by itself.
gar G forall bus in Int(0..(NUM_BUSSES - 1)).
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = gas_station) ) ->  
	( !next(shouldGoToGasStation[bus]) & next(destinationStation[bus]) = main_station & next(originStation[bus]) = gas_station );

// Guarantee for each bus: as long as the bus is in use and in the middle of a round (i.e not in main station which represents finishing of a full round), don't change the bus's line
gar G forall bus in Int(0..(NUM_BUSSES - 1)).
	( inUse[bus] & !(atDestinationStation[bus] & destinationStation[bus] = main_station) ) -> 
	( next(lineOfBus[bus]) = lineOfBus[bus] );
	

// Guarantee for each bus: while a the bus is on it's way to the gas station (meaning shouldGoToGasStation = true), it shouldn't stop (meaning stopAtNextStation = false);
gar G forall bus in Int(0..(NUM_BUSSES - 1)).
	shouldGoToGasStation[bus] ->  
	next(stopAtNextStation[bus]) = false;


predicate atGasStation(Bus bus):
	atDestinationStation[bus] & (destinationStation[bus] = gas_station);	
	
counter numOfStopsPassedBus0 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus1 = 0;
	inc: atDestinationStation[0];
	reset: atGasStation(0);
	overflow: false;
}

counter numOfStopsPassedBus1 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus1 = 0;
	inc: atDestinationStation[1];
	reset: atGasStation(1);
	overflow: false;
}

counter numOfStopsPassedBus2 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus2 = 0;
	inc: atDestinationStation[2];
	reset: atGasStation(2);
	overflow: false;
}

counter numOfStopsPassedBus3 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus3 = 0;
	inc: atDestinationStation[3];
	reset: atGasStation(3);
	overflow: false;
}

counter numOfStopsPassedBus4 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus4 = 0;
	inc: atDestinationStation[4];
	reset: atGasStation(4);
	overflow: false;
}

counter numOfStopsPassedBus5 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus5 = 0;
	inc: atDestinationStation[5];
	reset: atGasStation(5);
	overflow: false;
}


//Guarantee for each bus: if numOfStopsPassedBus = MAX_STATIONS_TO_GAS_STATION, then the bus shouldGoToGasStation
gar G numOfStopsPassedBus0 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[0]) = true;
gar G numOfStopsPassedBus1 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[1]) = true;
gar G numOfStopsPassedBus2 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[2]) = true;
gar G numOfStopsPassedBus3 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[3]) = true;
gar G numOfStopsPassedBus4 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[4]) = true;
gar G numOfStopsPassedBus5 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[5]) = true;

// Guarantee for each line: there is always at least one bus for each line
gar G forall line in Int(0..(NUM_LINES - 1)).
	exists bus in Int(0..(NUM_BUSSES-1)). lineOfBus[bus] = line;

// Guarantee for each station: If there are people waiting at a station and the bus didn't stop, than in next there will also be the same amount of people at this station
asm G forall station in Int(0..(NUM_STATIONS - 1)).
	forall bus in Int(0..(NUM_BUSSES-1)). ( !atDestinationStation[bus] | !(destinationStation[bus] = station) | !stopAtNextStation[bus] ) ->
	next(arePassengersWaiting[station]) = arePassengersWaiting[station];


predicate atStationAndPassengersDidNotHaveSeats(Bus bus):
	exists station in Int(0..(NUM_STATIONS-1)). (atDestinationStation[bus] & destinationStation[bus] = station) & arePassengersWaiting[station] & isBusFull[bus];

counter unstoppedStationsBus0 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus0 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(0);
	reset: extraBusSentLine[lineOfBus[0]] | !inUse[0];
	overflow: keep;
}

counter unstoppedStationsBus1 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus1 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(1);
	reset: extraBusSentLine[lineOfBus[1]] | !inUse[1];
	overflow: keep;
}

counter unstoppedStationsBus2 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus2 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(2);
	reset: extraBusSentLine[lineOfBus[2]] | !inUse[2];
	overflow: keep;
}

counter unstoppedStationsBus3 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus3 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(3);
	reset: extraBusSentLine[lineOfBus[3]] | !inUse[3];
	overflow: keep;	
}

counter unstoppedStationsBus4 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus4 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(4);
	reset: extraBusSentLine[lineOfBus[4]] | !inUse[4] ;
	overflow: keep;	
}

counter unstoppedStationsBus5 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus5 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(5);
	reset: extraBusSentLine[lineOfBus[5]] | !inUse[5];
	overflow: keep;	
}

// TODO: for every reserve bus: add stoppedStationsBus counters which indicate there is no need for the extra bus
	
//Guarantee for each bus: if unstoppedStationsBus counter = MAX_UNSTOPPED_STATIONS, try to get extra bus
// TODO : check why "Value 0 not in domain of lineOfBus" is printed. It seems like there is no problem.
gar G unstoppedStationsBus0 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[0]] = true;
gar G unstoppedStationsBus1 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[1]] = true;
gar G unstoppedStationsBus2 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[2]] = true;
gar G unstoppedStationsBus3 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[3]] = true;
gar G unstoppedStationsBus4 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[4]] = true;
gar G unstoppedStationsBus5 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[5]] = true;

// Guarantee for each line: if extra bus is needed for the this line, go through the reserve busses, if it's free allocate it to this line
// TODO: think how to make sure that not both busses will turn to be in use in case there is only one line which need extra bus.
// TODO: check how spectra works when inUse gets updated - in the middle of the loop or only at the end? (in order to make sure multiple busses will not allocate the same bus)
gar G forall line in Int(0..(NUM_LINES - 1)). forall reserveBus in Int (4..5). (!inUse[reserveBus] & needExtraBusForLine[line] ) -> (next(inUse[reserveBus]) = true & lineOfBus[reserveBus] = line );

// Guarantee for each reserve bus: there are free busses and some line needs extra bus, one of them should turn to be in use
// TODO: consider to remove and replace with last guarantee
gar G forall bus in Int (4..5). !inUse[bus] & (exists line in Int(0..(NUM_LINES - 1)). needExtraBusForLine[line]) -> next(inUse[bus]) = true;

// Guarantee for each line: if an extra bus was sent to this line, needExtraBusForLine = false
gar G forall line in Int(0..(NUM_LINES - 1)). extraBusSentLine[line] -> next(needExtraBusForLine[line]) = false;
