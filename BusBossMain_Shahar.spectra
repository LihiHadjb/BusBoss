import "./imports/DwyerPatterns.spectra"

spec BusBoss_sprint02

define NUM_BUSSES := 4; // 2 for each line (A and B) + 2 reserve
define NUM_RESERVE_BUSSES := 2;
define MAX_ROUNDS_TO_GAS_STATION := 5;
define MAX_UNSTOPPED_STATIONS := 3;
define NUM_STATIONS := 6;
define NUM_LINES := 2;
define NUM_ROUNDS_TO_FREE_RESERVE_BUS := 2;



//Lines
define A := 0;
define B := 1;

sys boolean[NUM_LINES] extraBusSentLine;

//_______Stations________

//Local Stations
define a1 := 0;
define a2 := 1;

define b1 := 2;
define b2 := 3;

//Other Stations
define main_station := 4;
define gas_station := 5;




//_______Busses________

type Bus = Int(0..(NUM_BUSSES - 1));
 
env boolean [NUM_BUSSES] isBusFull;
env boolean[NUM_BUSSES] isStopPressed;
env boolean[NUM_BUSSES] atDestinationStation;
env boolean [NUM_BUSSES] arePassengersWaitingInNextStation;
env boolean [NUM_BUSSES] atGasStation;  
env boolean [NUM_BUSSES] atMainStation; 
env boolean [NUM_RESERVE_BUSSES] isParking;

sys Int(0..(NUM_LINES - 1))[NUM_RESERVE_BUSSES] lineOfReserveBus;
sys boolean[NUM_BUSSES] stopAtNextStation;
sys boolean[NUM_BUSSES] shouldGoToGasStation;


//assumptions
asm GF atDestinationStation[0];
asm GF atDestinationStation[1];
asm GF atDestinationStation[2];
asm GF atDestinationStation[3];

asm GF isParking[0];
asm GF isParking[1];

//asm G forall bus in Int(0..(NUM_BUSSES - 1)).
//	!atDestinationStation[bus] &  arePassengersWaitingInNextStation[bus]->
//	next(arePassengersWaitingInNextStation[bus]) = arePassengersWaitingInNextStation[bus];


asm GF atMainStation[2];
asm GF atMainStation[3];



// __________Initial guarantees______________

//// Guarantee for each bus: at the beginning, the bus is at main station and shouldn't go to gas station.
gar forall bus in Int(0..(NUM_BUSSES - 1)). shouldGoToGasStation[bus]=false;

//// Guarantee for each bus: at the beginning, reserve busses are not in use and other busses are in use.
gar forall line in Int(0..(NUM_LINES-1)). extraBusSentLine[line] = false;


asm forall bus in Int(0..(NUM_BUSSES - 1)). isStopPressed[bus]=false;
asm forall bus in Int(0..(NUM_BUSSES - 1)). isBusFull[bus]=false;
asm forall bus in Int(0..(NUM_BUSSES - 1)). atDestinationStation[bus]=false;
asm forall bus in Int(0..(NUM_BUSSES - 1)). arePassengersWaitingInNextStation[bus]=false;
asm forall bus in Int(0..(NUM_BUSSES - 1)). atGasStation[bus]=false;
asm forall bus in Int(0..(NUM_RESERVE_BUSSES - 1)). isParking[bus]=true;


// ____scenarios_____
//______________ Rain Scenario_________________

env boolean isRaining;
// If it's raining, every bus should stop at every station, except busses that are on their way to the gas station.
gar G forall bus in Int(0..(NUM_BUSSES - 1)). isRaining & !shouldGoToGasStation[bus] -> next(stopAtNextStation[bus]) = true;






// __________when should stop at station and when should go to gas station


// Assumption for each bus: if isStopPressed and the bus didn't stop yet, isStopPressed should remain true
//asm isStopPressedNotTurningFalseBeforeReachingDestination0:
//	pBecomesTrue_betweenQandR(atDestinationStation[0], isStopPressed[0], !isStopPressed[0]);
//asm isStopPressedNotTurningFalseBeforeReachingDestination1:
//  pBecomesTrue_betweenQandR(atDestinationStation[1], isStopPressed[1], !isStopPressed[1]);
//asm isStopPressedNotTurningFalseBeforeReachingDestination2:
//  pBecomesTrue_betweenQandR(atDestinationStation[2], isStopPressed[2], !isStopPressed[2]);
//asm isStopPressedNotTurningFalseBeforeReachingDestination3:
//  pBecomesTrue_betweenQandR(atDestinationStation[3], isStopPressed[3], !isStopPressed[3]);





// Guarantee for each bus: while a the bus is on it's way to the gas station (meaning shouldGoToGasStation = true), it shouldn't stop (meaning next(shouldStop) = false),
gar G forall bus in Int(0..(NUM_BUSSES - 1)). shouldGoToGasStation[bus] -> next(stopAtNextStation[bus])=false;

// Don't stop at station if bus is full and no one wants to get off the bus
gar G forall bus in Int(0..(NUM_BUSSES - 1)). (isBusFull[bus] & !isStopPressed[bus] & !isRaining) -> next(stopAtNextStation[bus])=false;

//For each bus, it will stop if there are people waiting or if stop button was presses (unless it needs to go to the gas station)
gar G forall bus in Int(0..(NUM_BUSSES - 1)). !shouldGoToGasStation[bus] & !(isBusFull[bus] & !isStopPressed[bus]) & (arePassengersWaitingInNextStation[bus] | isStopPressed[bus])  -> next(stopAtNextStation[bus])=true;


counter numOfStopsPassedBus0 (0..MAX_ROUNDS_TO_GAS_STATION){
	numOfStopsPassedBus0 = 0;
	inc: atMainStation[0] & !atGasStation[0];
	reset: atGasStation[0];
	overflow: keep;
}

counter numOfStopsPassedBus1 (0..MAX_ROUNDS_TO_GAS_STATION){
	numOfStopsPassedBus1 = 0;
	inc: atMainStation[1] & !atGasStation[1];
	reset: atGasStation[1];
	overflow: keep;
}

counter numOfStopsPassedBus2 (0..MAX_ROUNDS_TO_GAS_STATION){
	numOfStopsPassedBus2 = 0;
	inc: atMainStation[2] & !atGasStation[2];
	reset: atGasStation[2];
	overflow: keep;
}

counter numOfStopsPassedBus3 (0..MAX_ROUNDS_TO_GAS_STATION){
	numOfStopsPassedBus3 = 0;
	inc: atMainStation[3]  & !atGasStation[3];
	reset: atGasStation[3];
	overflow: keep;
}

//Guarantee for each bus: if numOfStopsPassedBus = MAX_STATIONS_TO_GAS_STATION, then the bus shouldGoToGasStation
gar G !atGasStation[0] & numOfStopsPassedBus0 = MAX_ROUNDS_TO_GAS_STATION iff next(shouldGoToGasStation[0]) = true;
gar G !atGasStation[1] & numOfStopsPassedBus1 = MAX_ROUNDS_TO_GAS_STATION iff next(shouldGoToGasStation[1]) = true;
gar G !atGasStation[2] & numOfStopsPassedBus2 = MAX_ROUNDS_TO_GAS_STATION iff next(shouldGoToGasStation[2]) = true;
gar G !atGasStation[3] & numOfStopsPassedBus3 = MAX_ROUNDS_TO_GAS_STATION iff next(shouldGoToGasStation[3]) = true;



define BothCanBeUsed := reserveBusCanBeUsed(0) & reserveBusCanBeUsed(1);

define BothCantBeUsed := !reserveBusCanBeUsed(0) & !reserveBusCanBeUsed(1);

define Only2CanBeUsed := reserveBusCanBeUsed(0) & !reserveBusCanBeUsed(1);

define Only3CanBeUsed := !reserveBusCanBeUsed(0) & reserveBusCanBeUsed(1);

define AtLeastOneCanBeUsed := BothCanBeUsed | Only2CanBeUsed | Only3CanBeUsed;


predicate atStationAndPassengersDidNotHaveSeats(Bus bus):
	atDestinationStation[bus] & !stopAtNextStation[bus];


predicate reserveBusCanBeUsed(Bus bus):
	isParking[bus];




// _____________________Rush hours______________
counter unstoppedStationsLineA (0..(MAX_UNSTOPPED_STATIONS)){
	unstoppedStationsLineA = 0;
	inc: !extraBusSentLine[A] & (atStationAndPassengersDidNotHaveSeats(0) | (atStationAndPassengersDidNotHaveSeats(2) & lineOfReserveBus[0]=A) | ( atStationAndPassengersDidNotHaveSeats(3) & lineOfReserveBus[1]=A));
	reset: extraBusSentLine[A];
	overflow: keep;
}


monitor boolean waitingA{
	!waitingA;
	G ((unstoppedStationsLineA=MAX_UNSTOPPED_STATIONS | waitingA)) & !extraBusSentLine[A] <-> next(waitingA);
}

gar GF !waitingA;

//dont send more resreve busses than available
gar G next(extraBusSentLine[A]) & next(extraBusSentLine[B]) -> BothCanBeUsed;
gar G next(extraBusSentLine[A]) & !next(extraBusSentLine[B]) -> AtLeastOneCanBeUsed;
gar G !next(extraBusSentLine[A]) & next(extraBusSentLine[B]) -> AtLeastOneCanBeUsed;
//gar G !next(extraBusSentLine[A]) & !next(extraBusSentLine[B]) -> !waitingA & !waitingB;

//dont send for no reason
gar G next(extraBusSentLine[A]) -> waitingA;
gar G next(extraBusSentLine[B]) -> waitingB;


gar G (extraBusSentLine[A]) & (extraBusSentLine[B]) -> (lineOfReserveBus[0]=A & lineOfReserveBus[1]=B) | (lineOfReserveBus[0]=B & lineOfReserveBus[1]=A);

gar G next(extraBusSentLine[A]) & !next(extraBusSentLine[B]) & Only2CanBeUsed -> next(lineOfReserveBus[0]) = A;
gar G next(extraBusSentLine[A]) & !next(extraBusSentLine[B]) & Only3CanBeUsed -> next(lineOfReserveBus[1]) = A;
gar G next(extraBusSentLine[A]) & !next(extraBusSentLine[B]) & BothCanBeUsed -> next(lineOfReserveBus[0]) = A | next(lineOfReserveBus[1]) = A;


gar G !next(extraBusSentLine[A]) & next(extraBusSentLine[B]) & Only2CanBeUsed -> next(lineOfReserveBus[0]) = B;
gar G !next(extraBusSentLine[A]) & next(extraBusSentLine[B]) & Only3CanBeUsed -> next(lineOfReserveBus[1]) = B;
gar G !next(extraBusSentLine[A]) & next(extraBusSentLine[B]) & BothCanBeUsed -> next(lineOfReserveBus[1]) = B | next(lineOfReserveBus[1]) = B;




counter unstoppedStationsLineB (0..(MAX_UNSTOPPED_STATIONS)){
	unstoppedStationsLineB = 0;
	inc: !extraBusSentLine[B] & (atStationAndPassengersDidNotHaveSeats(1) | (atStationAndPassengersDidNotHaveSeats(2) & lineOfReserveBus[0]=B) | ( atStationAndPassengersDidNotHaveSeats(3) & lineOfReserveBus[1]=B));
	reset: extraBusSentLine[B];
	overflow: keep;
}


monitor boolean waitingB{
	!waitingB;
	G ((unstoppedStationsLineB=MAX_UNSTOPPED_STATIONS | waitingB)) & !extraBusSentLine[B] <-> next(waitingB);
}

gar GF !waitingB;



//as long as the bus is in use and in the middle of a round (i.e not in main station which represents finishing of a full round), don't change the bus's line
gar G forall bus in Int(0..(NUM_RESERVE_BUSSES - 1)).
	!isParking[bus] ->
	( next(lineOfReserveBus[bus]) = lineOfReserveBus[bus] );



