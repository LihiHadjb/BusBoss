import "DwyerPatterns.spectra"

spec BusBoss_sprint02

define NUM_BUSSES := 4; // 2 for each line (A and B) + 2 reserve
define MAX_STATIONS_TO_GAS_STATION := 10;
define MAX_UNSTOPPED_STATIONS := 4;
define NUM_STATIONS := 6;
define NUM_LINES := 2;
define NUM_ROUNDS_TO_FREE_RESERVE_BUS := 3;

// ____scenarios_____
//TODO: If it is raining, than the bus should wait 2 steps in each station it stops at in order to help passengers get settled
env boolean isRaining;

//Lines
define A := 0;
define B := 1;

sys boolean[NUM_LINES] extraBusSentLine;
sys boolean[NUM_LINES] needExtraBusForLine;

//_______Stations________

env boolean [NUM_STATIONS] arePassengersWaiting;

//Local Stations
define a1 := 0;
define a2 := 1;

define b1 := 2;
define b2 := 3;

//Other Stations
define main_station := 4;
define gas_station := 5;

// Assumption for each station: If there are people waiting at a station and the bus didn't stop, than in next there will still be people waiting.
asm G forall station in Int(0..(NUM_STATIONS - 1)).
	forall bus in Int(0..(NUM_BUSSES-1)). ( !atDestinationStation[bus] | !(destinationStation[bus] = station) | !stopAtNextStation[bus] ) ->
	next(arePassengersWaiting[station]) = arePassengersWaiting[station];

// ______Routes________

// Routes lengths
define line_A_length := 3;
define line_B_length := 3;
define a1_to_gas_station_length := 2;
define a2_to_gas_station_length := 4;
define b1_to_gas_station_length := 3;
define b2_to_gas_station_length := 2;
define main_station_to_gas_station_length := 2;

// Routes
define line_A_route[line_A_length] := {main_station, a1, a2};
define line_B_route[line_B_length] := {main_station, b1, b2};

// Routes from every station to gas_station
define a1_to_gas_station_route[a1_to_gas_station_length] := {a1, gas_station};
define a2_to_gas_station_route[a2_to_gas_station_length] := {a2, main_station, a1, gas_station};
define b1_to_gas_station_route[b1_to_gas_station_length] := {b1, b2, gas_station};
define b2_to_gas_station_route[b2_to_gas_station_length] := {b2, gas_station};
define main_station_to_gas_station_route[main_station_to_gas_station_length] := {main_station, gas_station};

//_______Busses________

type Bus = Int(0..(NUM_BUSSES - 1));

env boolean [NUM_BUSSES] isBusFull;
env boolean[NUM_BUSSES] isStopPressed;
env boolean[NUM_BUSSES] atDestinationStation;

sys Int(0..(NUM_LINES - 1))[NUM_BUSSES] lineOfBus;
sys boolean[NUM_BUSSES] inUse;
sys Int(0..(NUM_STATIONS - 1))[NUM_BUSSES] originStation;
sys Int(0..(NUM_STATIONS - 1))[NUM_BUSSES] destinationStation;
sys boolean[NUM_BUSSES] stopAtNextStation;
sys boolean[NUM_BUSSES] shouldGoToGasStation;
sys boolean[NUM_BUSSES] shouldStop;

predicate atSpecificDestinationStation(Bus bus, Int(0..(NUM_STATIONS - 1)) station):
	atDestinationStation[bus] & (destinationStation[bus] = station);

// Assumption for each bus - if some bus needs to wait at current station and not at destination station yet, next(atDestinationStation) = atDestinationStation
asm G forall bus in Int(0..(NUM_BUSSES - 1)). shouldStop[bus] -> next(atDestinationStation[bus]) = atDestinationStation[bus];

// Initial guarantees

// Guarantee for each bus: at the beginning, the bus is at main station and shouldn't go to gas station.
gar forall bus in Int(0..(NUM_BUSSES - 1)). originStation[bus] = main_station & shouldGoToGasStation[bus]=false;
// Guarantee for each reserve bus: at the beginning, they are not in use.
gar forall bus in Int(2..3). inUse[bus] = false;
// Guarantee for each bus which isn't reserve bus: at the beginning, they are in use.
gar forall bus in Int(0..1). inUse[bus] = true;
// Guarantee for bus0: at the beginning, the bus is allocated to line A.
gar lineOfBus[0] = A;
// Guarantee for bus1: at the beginning, the bus is allocated to line B.
gar lineOfBus[1] = B;


// Guarantee for each line: if at destinantionStation and shouldn't go to gas station(!), set new destination to be next station of line route and origin to be old destination. 
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(line_A_length-1)). 
	( (lineOfBus[bus] = 0) & (!shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = line_A_route[i]) ) ->  
	( next(destinationStation[bus]) = line_A_route[(i+1)%line_A_length] & next(originStation[bus]) = line_A_route[(i)%line_A_length] );
	
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(line_B_length-1)). 
	( (lineOfBus[bus] = 0) & (!shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = line_B_route[i]) ) ->  
	( next(destinationStation[bus]) = line_B_route[(i+1)%line_B_length] & next(originStation[bus]) = line_B_route[(i)%line_B_length] );

//TODO: think how to implement these guarantees: 
// Guarantee for each station: if a bus at destinationStation and should go to gas station, set new destination to be next station of
// from_destination_Station_to_gas_station route and origin to be old destination.
//gar G forall bus in Int(0..(NUM_BUSSES - 1)). (shouldGoToGasStation[bus]) & ( exists i in Int(0..(a1_to_gas_station_length-2)). 
//	( atDestinationStation[bus] & (destinationStation[bus] = a1_to_gas_station_route[i]) ) ) ->  
//	( next(destinationStation[bus]) = a1_to_gas_station_route[i+1] & next(originStation[bus]) = a1_to_gas_station_route[i] );
//	
//gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(a2_to_gas_station_length-2)). 
//	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = a2_to_gas_station_route[i]) ) ->  
//	( next(destinationStation[bus]) = a2_to_gas_station_route[(i+1)] & next(originStation[bus]) = a2_to_gas_station_route[(i)] );
//	
//gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(b1_to_gas_station_length-2)). 
//	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = b1_to_gas_station_route[i]) ) ->  
//	( next(destinationStation[bus]) = b1_to_gas_station_route[(i+1)] & next(originStation[bus]) = b1_to_gas_station_route[(i)] );
//
//gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(b2_to_gas_station_length-2)). 
//	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = b2_to_gas_station_route[i]) ) ->  
//	( next(destinationStation[bus]) = b2_to_gas_station_route[(i+1)] & next(originStation[bus]) = b2_to_gas_station_route[(i)] );
//	
//gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall i in Int(0..(main_station_to_gas_station_length-2)). 
//	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = main_station_to_gas_station_route[i]) ) ->  
//	( next(destinationStation[bus]) = main_station_to_gas_station_route[(i+1)] & next(originStation[bus]) = main_station_to_gas_station_route[(i)] );

// Guarantee for each bus: if should go to gas station and bus is at gas station, set shouldGoToGasStation to false and go back to main station.
// TODO: GUI will know how to move a bus from gas station to main station by itself.
gar G forall bus in Int(0..(NUM_BUSSES - 1)).
	( (shouldGoToGasStation[bus]) & atDestinationStation[bus] & (destinationStation[bus] = gas_station) ) ->  
	( next(shouldGoToGasStation[bus])=false & next(destinationStation[bus]) = main_station & next(originStation[bus]) = gas_station );

// Guarantee for each bus: as long as the bus is in use and in the middle of a round (i.e not in main station which represents finishing of a full round), don't change the bus's line
gar G forall bus in Int(0..(NUM_BUSSES - 1)).
	( inUse[bus] & !(atDestinationStation[bus] & destinationStation[bus] = main_station) ) -> 
	( next(lineOfBus[bus]) = lineOfBus[bus] );

predicate bothBussesAtSomeStation(Bus bus1, Bus bus2):
	exists station in Int(0..(NUM_STATIONS - 1)). atSpecificDestinationStation(bus1, station) & atSpecificDestinationStation(bus2, station);

// Guarantee for each bus: while a the bus is on it's way to the gas station (meaning shouldGoToGasStation = true), it shouldn't stop (meaning next(shouldStop) = false),
// except for the case there is a collision with another bus
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall bus2 in Int(0..(NUM_BUSSES - 1)). 
	shouldGoToGasStation[bus] & !bothBussesAtSomeStation(bus, bus2)
	-> next(shouldStop[bus]) = false;

// Guarantee for each bus: if the bus at destinationStation and isStopPressed OR that there are people waiting at next station but the bus isn't on it's way to the gas station, next(shouldStop) = true
gar G forall bus in Int(0..(NUM_BUSSES - 1)). forall station in Int(0..(NUM_STATIONS - 1)). 
	(atDestinationStation[bus] & destinationStation[bus] = station) & !shouldGoToGasStation[bus] & (isStopPressed[bus] | arePassengersWaiting[station])
	-> next(shouldStop[bus]) = true;
	
// Assumption for each bus: if isStopPressed and the bus didn't stop yet, isStopPressed should remain true
asm isStopPressedNotTurningFalseBeforeReachingDestination0:
  pBecomesTrue_betweenQandR(atDestinationStation[0], isStopPressed[0], !isStopPressed[0]);
asm isStopPressedNotTurningFalseBeforeReachingDestination1:
  pBecomesTrue_betweenQandR(atDestinationStation[1], isStopPressed[1], !isStopPressed[1]);
asm isStopPressedNotTurningFalseBeforeReachingDestination2:
  pBecomesTrue_betweenQandR(atDestinationStation[2], isStopPressed[2], !isStopPressed[2]);
asm isStopPressedNotTurningFalseBeforeReachingDestination3:
  pBecomesTrue_betweenQandR(atDestinationStation[3], isStopPressed[3], !isStopPressed[3]);
  
predicate atGasStation(Bus bus):
	atDestinationStation[bus] & (destinationStation[bus] = gas_station);	
	
counter numOfStopsPassedBus0 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus1 = 0;
	inc: atDestinationStation[0] & !atGasStation(0);
	reset: atGasStation(0);
	overflow: false;
}

counter numOfStopsPassedBus1 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus1 = 0;
	inc: atDestinationStation[1] & !atGasStation(1);
	reset: atGasStation(1);
	overflow: false;
}

counter numOfStopsPassedBus2 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus2 = 0;
	inc: atDestinationStation[2] & !atGasStation(2);
	reset: atGasStation(2);
	overflow: false;
}

counter numOfStopsPassedBus3 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus3 = 0;
	inc: atDestinationStation[3] & !atGasStation(3);
	reset: atGasStation(3);
	overflow: false;
}


//Guarantee for each bus: if numOfStopsPassedBus = MAX_STATIONS_TO_GAS_STATION, then the bus shouldGoToGasStation
gar G numOfStopsPassedBus0 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[0]) = true;
gar G numOfStopsPassedBus1 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[1]) = true;
gar G numOfStopsPassedBus2 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[2]) = true;
gar G numOfStopsPassedBus3 = MAX_STATIONS_TO_GAS_STATION ->  next(shouldGoToGasStation[3]) = true;

// Guarantee for each line: there is always at least one bus for each line
gar G forall line in Int(0..(NUM_LINES - 1)).
	exists bus in Int(0..(NUM_BUSSES-1)). lineOfBus[bus] = line;


predicate atStationAndPassengersDidNotHaveSeats(Bus bus):
	exists station in Int(0..(NUM_STATIONS-1)). (atDestinationStation[bus] & destinationStation[bus] = station) & arePassengersWaiting[station] & isBusFull[bus];

counter unstoppedStationsBus0 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus0 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(0);
	reset: extraBusSentLine[lineOfBus[0]] | !inUse[0];
	overflow: keep;
}

counter unstoppedStationsBus1 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus1 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(1);
	reset: extraBusSentLine[lineOfBus[1]] | !inUse[1];
	overflow: keep;
}

counter unstoppedStationsBus2 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus2 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(2);
	reset: extraBusSentLine[lineOfBus[2]] | !inUse[2];
	overflow: keep;
}

counter unstoppedStationsBus3 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus3 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(3);
	reset: extraBusSentLine[lineOfBus[3]] | !inUse[3];
	overflow: keep;	
}


// Counters for number of stations for every reserve bus
counter numberStationsOfReserveBus2 (0..NUM_ROUNDS_TO_FREE_RESERVE_BUS){
	numberStationsOfReserveBus2 = 0;
	inc: inUse[2] & atSpecificDestinationStation(2, 4); // 4 is main_station
	reset: !inUse[2];
	overflow: keep;
}

counter numberStationsOfReserveBus3 (0..NUM_ROUNDS_TO_FREE_RESERVE_BUS){
	numberStationsOfReserveBus3 = 0;
	inc: inUse[3] & atSpecificDestinationStation(3, 4); // 4 is main_station
	reset: !inUse[3];
	overflow: keep;
}

// Guarantee for every reserve bus: after X steps the reserve bus should turn !inUse
gar G numberStationsOfReserveBus2 = NUM_ROUNDS_TO_FREE_RESERVE_BUS -> !inUse[2]; // TODO: GUI should move the busses only id they're not in use
gar G numberStationsOfReserveBus3 = NUM_ROUNDS_TO_FREE_RESERVE_BUS -> !inUse[3];

	
//Guarantee for each bus: if unstoppedStationsBus counter = MAX_UNSTOPPED_STATIONS, try to get extra bus
// TODO : check why "Value 0 not in domain of lineOfBus" is printed. It seems like there is no problem.
//gar G unstoppedStationsBus0 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[0]] = true;
//gar G unstoppedStationsBus1 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[1]] = true;
//gar G unstoppedStationsBus2 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[2]] = true;
//gar G unstoppedStationsBus3 = MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[3]] = true;



// Guarantee for each line: if extra bus is needed for the this line, go through the reserve busses, if it's free allocate it to this line
// TODO: think how to make sure that not both busses will turn to be in use in case there is only one line which need extra bus.
// TODO: check how spectra works when inUse gets updated - in the middle of the loop or only at the end? (in order to make sure multiple busses will not allocate the same bus)
gar G forall line in Int(0..(NUM_LINES - 1)). forall reserveBus in Int (2..3). (!inUse[reserveBus] & needExtraBusForLine[line] ) -> (next(inUse[reserveBus]) = true & lineOfBus[reserveBus] = line );

// Guarantee for each reserve bus: there are free busses and some line needs extra bus, one of them should turn to be in use
// TODO: consider to remove and replace with last guarantee
gar G forall bus in Int (2..3). !inUse[bus] & (exists line in Int(0..(NUM_LINES - 1)). needExtraBusForLine[line]) -> next(inUse[bus]) = true;

// Guarantee for each line: if an extra bus was sent to this line, needExtraBusForLine = false
gar G forall line in Int(0..(NUM_LINES - 1)). extraBusSentLine[line] -> next(needExtraBusForLine[line]) = false;

// Guarantee - if 2 busses are at the same station, only one of them can continue to destination station and the other one should stop (to avoid collision)
gar G forall bus_i in Int(0..(NUM_BUSSES - 1)). forall bus_j in Int(0..(NUM_BUSSES - 1)). exists station in Int(0..(NUM_STATIONS - 1)). 
	atSpecificDestinationStation(bus_i, station) & atSpecificDestinationStation(bus_j, station) -> 
	!(next(shouldStop[bus_i]) & next(shouldStop[bus_j])) ;

// Guarantee - if some bus (which is in Use) needs to wait at the station, it's origin and destination should remain the same
gar G forall bus in Int(0..(NUM_BUSSES - 1)).  
	shouldStop[bus] & inUse[bus] -> ( next(originStation[bus]) = originStation[bus] & next(destinationStation[bus]) = destinationStation[bus] );


