spec BusBoss_sprint01

define NUM_BUSSES := 6;
define MAX_STATIONS_TO_GAS_STATION := 10;
define BOARD_WIDTH := 80;
define BOARD_LENGTH := 50;
define MAX_UNSTOPPED_STATIONS := 2;
define NUM_STATIONS := 10;
define NUM_LINES := 4;
type Dim = Int(0..(BOARD_WIDTH-1));

env boolean isRaining;//TODO: If it is raining, than the bus should wait 2 steps in each station it stops at in order to help passengers get settled


//Lines
type Line = Int(0..(NUM_LINES - 1));
define A :=0;
define B :=1;
define C :=2;
define G_W :=3;
define G_E :=4;

sys boolean[NUM_LINES] extraBusSentLine;
sys boolean[NUM_LINES] needExtraBusForLine;

//_______Stations________

type Station = Int(0..(NUM_STATIONS - 1));

// Stations coordinates
define stationX[NUM_STATIONS] := {0,0,0,0,0,0,0,0,0,0}; //TODO: update coordinates
define stationY[NUM_STATIONS] := {0,0,0,0,0,0,0,0,0,0};

//Local Stations
define a1 := 0;
define a2 := 1;

define b1 := 2;
define b2 := 3;

// General Line Stations
define g1_w := 4;
define g2_w := 5;

define g1_e := 6;
define g2_e := 7;

//Other Stations
define main_station := 8;
define gas_station := 9;

env boolean [NUM_STATIONS] arePassengersWaiting;

//define line_a_path = [mainStation, a1, a3, b4];
//define line_b_path = [a1, a3, b4, mainStation];
//define line_g_path = [a1, a3, b4, mainStation];
//define path_from_stationx_to_gas_station = [x, bla, bla2, gasStation];
//define path_from__gas_station_to_stationX = [x, bla, bla2, gasStation];
// TODO: Every bus should have currPath. If shouldGoToGasStation is true --> set currPath to be the path from currStationToGasStation
// currPath: If shouldGoToGasStation is true --> set currPath to be the path from currStationToGasStation.
// If shouldGoToGasStation turned false, go back to mainStation and set currPath to be line_bus_path
// TODO: Add guarantee - if 2 busses are in the same station, don't let their next station be the same.
// TODO: Add guarantee - if some bus is in x station, then it's next station can be: next_station_of_bus_path OR wait (which means nextStation = currStation)


//_______Busses________
type Bus = Int(0..(NUM_BUSSES - 1));
sys boolean[NUM_BUSSES] shouldGoToGasStation;


sys Dim [NUM_BUSSES][2] busCoordinates;

//TODO: maybe should be sys
env boolean [NUM_BUSSES] isBusFull;

env boolean[NUM_BUSSES] isStopPressed;

sys Int(0..3)[NUM_BUSSES] lineOfBus;

//TODO: in each step each bus should update if it is at some station. 
sys boolean[NUM_BUSSES] atGasStation;
sys boolean [NUM_BUSSES] atStation;

sys boolean[NUM_BUSSES] stopAtNextStation;
sys boolean[NUM_BUSSES] inUse;

sys boolean[NUM_BUSSES] nextStation;

//TODO:
//Add a guarantee that the system will not change a bus's line in the middle of a route.
//Optional: For the general lines, all people must leave the bus at the last station. 





//TODO: check if we can do this without duplicating the counter code
counter numOfStopsPassedBus0 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus1 = 0;
	inc: atStation[0];
	reset: atGasStation[0];
	overflow: false;
}

counter numOfStopsPassedBus1 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus1 = 0;
	inc: atStation[1];
	reset: atGasStation[1];
	overflow: false;
}

counter numOfStopsPassedBus2 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus2 = 0;
	inc: atStation[2];
	reset: atGasStation[2];
	overflow: false;
}

counter numOfStopsPassedBus3 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus3 = 0;
	inc: atStation[3];
	reset: atGasStation[3];
	overflow: false;
}

counter numOfStopsPassedBus4 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus4 = 0;
	inc: atStation[4];
	reset: atGasStation[4];
	overflow: false;
}

counter numOfStopsPassedBus5 (0..MAX_STATIONS_TO_GAS_STATION){
	numOfStopsPassedBus5 = 0;
	inc: atStation[5];
	reset: atGasStation[5];
	overflow: false;
}

//TODO:
//Add a guarantee that if numOfStopsPassedBus4=MAX_STATIONS_TO_GAS_STATION, than the bus shouldGoToGasStationBus4
//Add a guarantee that if shouldGoToGasStationBus4 is true, than the bus must go to the gas station
//if shouldGoToGasStationBus4, the next coordinate will be determined by the route from the current coordinate to the gas station.

//Add a guarantee that there is always at least one bus in each line

//If there are people waiting at a station and the bus didn't stop, than in next there will also be the same amount of people at this station


predicate atStationAndPassengersDidNotHaveSeats(Bus bus):
	exists i in Int(0..(NUM_STATIONS-1)). busAtStation(bus, i) & arePassengersWaiting[i] & isBusFull[bus];
	
predicate busAtStation(Bus bus, Int(0..(NUM_STATIONS-1)) station):
	busCoordinates[bus][0] = stationX[station] & busCoordinates[bus][1] = stationY[station];
	

//If the bus stopped at a station and there were people waiting in this station and the bus had enough free seats, than people go on the bus
//Otherwise, the bus should inc its counter for unstopped stations. 

//TODO: find out if we can do the counter unlimited
//TODO: find out if we can do an array of counters
counter unstoppedStationsBus0 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus0 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(0);
	reset: extraBusSentLine[lineOfBus[0]];
	overflow: keep;
}

counter unstoppedStationsBus1 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus1 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(1);
	reset: extraBusSentLine[lineOfBus[1]];
	overflow: keep;
}

counter unstoppedStationsBus2 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus2 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(2);
	reset: extraBusSentLine[lineOfBus[2]];
	overflow: keep;
}

counter unstoppedStationsBus3 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus3 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(3);
	reset: extraBusSentLine[lineOfBus[3]];
	overflow: keep;	
}

counter unstoppedStationsBus4 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus4 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(4);
	reset: extraBusSentLine[lineOfBus[4]];
	overflow: keep;	
}

counter unstoppedStationsBus5 (0..MAX_UNSTOPPED_STATIONS){
	unstoppedStationsBus5 = 0;
	inc: atStationAndPassengersDidNotHaveSeats(5);
	reset: extraBusSentLine[lineOfBus[5]];
	overflow: keep;	
}

predicate haveAvailableBus():
	!inUse[4] | !inUse[5];
	

gar G unstoppedStationsBus0=MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[0]]=true;
gar G unstoppedStationsBus1=MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[1]]=true;
gar G unstoppedStationsBus2=MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[2]]=true;
gar G unstoppedStationsBus3=MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[3]]=true;
gar G unstoppedStationsBus4=MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[4]]=true;
gar G unstoppedStationsBus5=MAX_UNSTOPPED_STATIONS -> needExtraBusForLine[lineOfBus[5]]=true;

gar G forall line in Int(0..(NUM_LINES - 1)). extraBusSentLine[line] -> needExtraBusForLine[line]=false;

gar G forall line in Int(0..(NUM_LINES - 1)). needExtraBusForLine[line] & haveAvailableBus() -> next(extraBusSentLine[line])=true;

//Add a guarantee that sends one of the available busses when needed, and haveAvailableBus
//Add to the extra busses a field that indicates if this bus is in use or not.


